import type { Plugin, ViteDevServer } from 'vite'
import fs from 'node:fs'
import path from 'node:path'
import { fileURLToPath } from 'node:url'
import chokidar from 'chokidar'

const VIRTUAL_ROUTES_ID = 'virtual:@btc/auto/routes'
const VIRTUAL_APIS_ID = 'virtual:@btc/auto/apis'
const VIRTUAL_META_ID = 'virtual:@btc/auto/meta'
const RESOLVED_ROUTES_ID = '\0' + VIRTUAL_ROUTES_ID
const RESOLVED_APIS_ID = '\0' + VIRTUAL_APIS_ID
const RESOLVED_META_ID = '\0' + VIRTUAL_META_ID

type ModuleCfg = {
  id: string
  title?: string
  category?: string
  icon?: string
  showInMenu?: boolean
  apiBase?: string
  devPort?: number
  routeMeta?: Record<string, any>
}

type ScanState = {
  root: string
  modulesDir: string
  modules: Record<string, {
    cfg: ModuleCfg
    pages: string[] // 绝对路径
  }>
}

export function btcAutoDiscover(): Plugin {
  let server: ViteDevServer | null = null
  let state: ScanState

  const scan = async (root: string): Promise<ScanState> => {
    const modulesDir = path.join(root, 'src/modules')
    const modules: ScanState['modules'] = {}
    
    if (!fs.existsSync(modulesDir)) {
      return { root, modulesDir, modules }
    }

    const moduleIds = fs.readdirSync(modulesDir)
      .filter(d => fs.statSync(path.join(modulesDir, d)).isDirectory())

    for (const mid of moduleIds) {
      const mdir = path.join(modulesDir, mid)
      const cfgPath = path.join(mdir, 'module.config.ts')
      const pagesDir = path.join(mdir, 'pages')
      
      let cfg: ModuleCfg = { id: mid }
      
      if (fs.existsSync(cfgPath)) {
        try {
          // 使用正确的 file:// URL 格式
          const fileUrl = `file://${cfgPath.replace(/\\/g, '/')}`
          const configModule = await import(fileUrl + '?t=' + Date.now())
          cfg = { id: mid, ...configModule.default }
        } catch (error) {
          console.warn(`Failed to load module config for ${mid}:`, error)
        }
      }
      
      const pages = fs.existsSync(pagesDir)
        ? walkFiles(pagesDir).filter(f => /\.(vue|tsx)$/.test(f))
        : []
      
      modules[mid] = { cfg, pages }
    }
    
    return { root, modulesDir, modules }
  }

  const invalidate = (id: string) => {
    if (!server) return
    const mod = server.moduleGraph.getModuleById(id)
    if (mod) {
      server.moduleGraph.invalidateModule(mod)
    }
    // 触发全页面刷新（保守实现，稳定可靠）
    server.ws.send({ type: 'full-reload' })
  }

  const genRoutesCode = () => {
    const lines: string[] = []
    lines.push(`import { h } from 'vue'`)
    lines.push(`export const routes = [`)
    
    for (const [mid, m] of Object.entries(state.modules)) {
      const base = `/${m.cfg.id}`
      for (const abs of m.pages) {
        // 使用绝对路径，让 Vite 正确解析
        const rel = abs.replace(/\\/g, '/')
        const routePath = toRoutePath(base, abs, m.cfg.id)
        
        // 生成更丰富的meta信息
        const enhancedMeta = {
          title: m.cfg.title || m.cfg.id,
          category: m.cfg.category || 'app',
          icon: m.cfg.icon || 'Setting',
          showInMenu: m.cfg.showInMenu !== false,
          ...m.cfg.routeMeta
        }
        
        const meta = JSON.stringify(enhancedMeta)
        lines.push(`  { path: '${routePath}', component: () => import('${rel}'), meta: ${meta} },`)
      }
    }
    
    lines.push(`]`)
    lines.push(`export default routes`)
    return lines.join('\n')
  }

  const genApisCode = () => {
    const table: Record<string, { base?: string; devPort?: number }> = {}
    for (const [mid, m] of Object.entries(state.modules)) {
      table[mid] = { base: m.cfg.apiBase, devPort: m.cfg.devPort }
    }
    return `export const apis = ${JSON.stringify(table)};\nexport const apiOf = (m) => apis[m];\nexport default apis`
  }

  const genMetaCode = () => {
    const meta = Object.fromEntries(
      Object.entries(state.modules).map(([k, m]) => [k, m.cfg])
    )
    return `export const meta = ${JSON.stringify(meta)}; export default meta`
  }

  const generateTypeDeclarations = () => {
    const typeContent = `// Auto-generated by @btc/auto-discover
declare module 'virtual:@btc/auto/routes' {
  export const routes: any[]
  export default routes
}

declare module 'virtual:@btc/auto/apis' {
  export const apis: Record<string, { base?: string; devPort?: number }>
  export function apiOf(id: string): { base?: string; devPort?: number }
  export default apis
}

declare module 'virtual:@btc/auto/meta' {
  const meta: any
  export default meta
}
`
    
    const typesDir = path.join(state.root, 'src/types')
    if (!fs.existsSync(typesDir)) {
      fs.mkdirSync(typesDir, { recursive: true })
    }
    
    const typeFile = path.join(typesDir, 'btc-auto-discover.d.ts')
    fs.writeFileSync(typeFile, typeContent)
  }

  return {
    name: 'btc-auto-discover',
    enforce: 'pre',

    async configResolved(config) {
      state = await scan(config.root)
      generateTypeDeclarations()
    },

    configureServer(_server) {
      server = _server
      
      // 监听变更
      const watcher = chokidar.watch([
        path.join(_server.config.root, 'src/modules/**/pages/**/*'),
        path.join(_server.config.root, 'src/modules/**/module.config.ts'),
      ], { ignoreInitial: true })

      watcher.on('add', async () => {
        state = await scan(_server.config.root)
        invalidate(RESOLVED_ROUTES_ID)
        generateTypeDeclarations()
      })
      
      watcher.on('unlink', async () => {
        state = await scan(_server.config.root)
        invalidate(RESOLVED_ROUTES_ID)
        generateTypeDeclarations()
      })
      
      watcher.on('change', async () => {
        state = await scan(_server.config.root)
        invalidate(RESOLVED_APIS_ID)
        generateTypeDeclarations()
      })

      // 健康检查与调试面板
      _server.middlewares.use('/__btc__/health', (_req, res) => {
        res.setHeader('content-type', 'application/json')
        res.end(JSON.stringify({ 
          ok: true, 
          modules: Object.keys(state.modules),
          timestamp: new Date().toISOString()
        }))
      })
      
      _server.middlewares.use('/__btc__/panel', (_req, res) => {
        res.setHeader('content-type', 'application/json')
        res.end(JSON.stringify(state.modules, null, 2))
      })

      // 添加路由代码调试端点
      _server.middlewares.use('/__btc__/routes-code', (_req, res) => {
        res.setHeader('content-type', 'text/plain')
        res.end(genRoutesCode())
      })

      // 代理：把 /api/<module> 定向到对应 devPort
      for (const [mid, m] of Object.entries(state.modules)) {
        if (!m.cfg.devPort || !m.cfg.apiBase) continue
        const target = `http://localhost:${m.cfg.devPort}`
        const prefix = m.cfg.apiBase
        _server.config.server.proxy = _server.config.server.proxy || {}
        _server.config.server.proxy[prefix] = { target, changeOrigin: true }
      }
    },

    resolveId(id) {
      if (id === VIRTUAL_ROUTES_ID) return RESOLVED_ROUTES_ID
      if (id === VIRTUAL_APIS_ID) return RESOLVED_APIS_ID
      if (id === VIRTUAL_META_ID) return RESOLVED_META_ID
    },

    load(id) {
      if (id === RESOLVED_ROUTES_ID) return genRoutesCode()
      if (id === RESOLVED_APIS_ID) return genApisCode()
      if (id === RESOLVED_META_ID) return genMetaCode()
    },
  }
}

function walkFiles(dir: string): string[] {
  const out: string[] = []
  for (const name of fs.readdirSync(dir)) {
    const p = path.join(dir, name)
    const s = fs.statSync(p)
    if (s.isDirectory()) {
      out.push(...walkFiles(p))
    } else {
      out.push(p)
    }
  }
  return out
}

function toRoutePath(base: string, abs: string, moduleId: string): string {
  // .../modules/<moduleId>/pages/foo/[id].vue -> /<moduleId>/foo/:id
  const parts = abs.split(path.sep)
  const pagesIndex = parts.lastIndexOf('pages')
  if (pagesIndex === -1) return base
  
  const rel = parts.slice(pagesIndex + 1).join('/')
  return (base + '/' + rel
    .replace(/index\.(vue|tsx)$/, '')
    .replace(/\.vue$|\.tsx$/, '')
    .replace(/\[(\.{3})?([^\]]+)\]/g, (_, dots, name) => 
      dots ? `:${name}(.*)` : `:${name}`
    )
  ).replace(/\/+/g, '/')
}
